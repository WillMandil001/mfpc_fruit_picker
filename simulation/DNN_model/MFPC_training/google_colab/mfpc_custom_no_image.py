# -*- coding: utf-8 -*-
"""MFPC_custom_no_image.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eICQ69-fUUmT-QOYclFfAGouAJHDTw-b
"""

# Unzip data
!unzip "/content/drive/My Drive/Masters Year/data_mfpc/data_set_003.zip"

import cv2
import matplotlib
import numpy as np
import pandas as pd
from PIL import Image
import tensorflow as tf
from tensorflow import keras
import matplotlib.image as mpimg
from matplotlib import pyplot as plt
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Activation, Dropout, Flatten, Conv2D, MaxPooling2D
from tensorflow.keras.callbacks import EarlyStopping
np.random.seed(1000)
from sklearn import preprocessing
from tensorflow.keras.models import Model
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.preprocessing import image
from tensorflow.keras.applications.resnet import preprocess_input

################################## Hyper Parameters ##################################################################
data_set_length = 165
trajectory_length = 5  # Not including start state

################################# Robot vel and pos ###################################################################
robot_positions = pd.read_csv('/content/data_set_003/robot_pos/data_set_' + str(0) + '_robot_data_store_position.csv', header=None)
robot_velocitys = pd.read_csv('/content/data_set_003/robot_vel/data_set_' + str(0) + '_robot_data_store_velocity.csv', header=None)
for i in range(1, data_set_length):
    robot_positions = pd.concat([robot_positions, pd.read_csv('/content/data_set_003/robot_pos/data_set_' + str(i) + '_robot_data_store_position.csv', header=None)])
    robot_velocitys = pd.concat([robot_velocitys, pd.read_csv('/content/data_set_003/robot_vel/data_set_' + str(i) + '_robot_data_store_velocity.csv', header=None)])

################################## Standardization for Robot States ###################################################################
robot_positions_names = robot_positions.columns
scaler = preprocessing.StandardScaler()
myScaler = scaler.fit(robot_positions)
robot_positions = myScaler.transform(robot_positions)
robot_positions = pd.DataFrame(robot_positions, columns=robot_positions_names)
print(robot_positions.shape)

robot_velocitys_names = robot_velocitys.columns
scaler = preprocessing.StandardScaler()
myScaler = scaler.fit(robot_velocitys)
robot_velocitys = myScaler.transform(robot_velocitys)
robot_velocitys = pd.DataFrame(robot_velocitys, columns=robot_velocitys_names)
print(robot_velocitys.shape)

################################## Load Strawberry Data ##################################################################
strawberry_1 = pd.read_csv('/content/data_set_003/straw_1/data_set_' + str(0) + '_strawberry_data_store_1.csv', delimiter=',', error_bad_lines=False,  header=None)
strawberry_2 = pd.read_csv('/content/data_set_003/straw_2/data_set_' + str(0) + '_strawberry_data_store_2.csv', delimiter=',', error_bad_lines=False, header=None)
strawberry_3 = pd.read_csv('/content/data_set_003/straw_3/data_set_' + str(0) + '_strawberry_data_store_3.csv', delimiter=',', error_bad_lines=False, header=None)
strawberry_4 = pd.read_csv('/content/data_set_003/straw_4/data_set_' + str(0) + '_strawberry_data_store_4.csv', delimiter=',', error_bad_lines=False, header=None)
strawberry_5 = pd.read_csv('/content/data_set_003/straw_5/data_set_' + str(0) + '_strawberry_data_store_5.csv', delimiter=',', error_bad_lines=False, header=None)
strawberry_states = strawberry_1
blank = strawberry_2
counter = 0
for i in range(counter, 2):
    strawberry_states = pd.concat([strawberry_states, blank], axis=1)

for i in range(1, data_set_length):
    strawberry_cluster_state = pd.read_csv('/content/data_set_003/straw_1/data_set_' + str(i) + '_strawberry_data_store_1.csv', delimiter=',', error_bad_lines=False, header=None)
    strawberry_2 = pd.read_csv('/content/data_set_003/straw_2/data_set_' + str(i) + '_strawberry_data_store_2.csv', delimiter=',', error_bad_lines=False, header=None)
    strawberry_3 = pd.read_csv('/content/data_set_003/straw_3/data_set_' + str(i) + '_strawberry_data_store_3.csv', delimiter=',', error_bad_lines=False, header=None)
    strawberry_4 = pd.read_csv('/content/data_set_003/straw_4/data_set_' + str(i) + '_strawberry_data_store_4.csv', delimiter=',', error_bad_lines=False, header=None)
    strawberry_5 = pd.read_csv('/content/data_set_003/straw_5/data_set_' + str(i) + '_strawberry_data_store_5.csv', delimiter=',', error_bad_lines=False, header=None)
    counter = 0
    if strawberry_2[0][0] != 100 and counter < 2:
        strawberry_cluster_state = pd.concat([strawberry_cluster_state, strawberry_2], axis=1)
        counter += 1
    if strawberry_3[0][0] != 100 and counter < 2:
        strawberry_cluster_state = pd.concat([strawberry_cluster_state, strawberry_3], axis=1)
        counter += 1
    if strawberry_4[0][0] != 100 and counter < 2:
        strawberry_cluster_state = pd.concat([strawberry_cluster_state, strawberry_4], axis=1)
        counter += 1
    if strawberry_5[0][0] != 100 and counter < 2:
        strawberry_cluster_state = pd.concat([strawberry_cluster_state, strawberry_5], axis=1)
        counter += 1
    for i in range(counter, 2):
        strawberry_cluster_state = pd.concat([strawberry_cluster_state, blank], axis=1)
    strawberry_states = pd.concat([strawberry_states, strawberry_cluster_state], axis=0)
print(strawberry_states.iloc[0])

################################## Standardization for Strawberry States ###################################################################
strawberry_state_names = strawberry_states.columns
scaler = preprocessing.StandardScaler()
myScaler = scaler.fit(strawberry_states)
strawberry_states = myScaler.transform(strawberry_states)
strawberry_states = pd.DataFrame(strawberry_states, columns=strawberry_state_names)
print(strawberry_states.shape)
print(strawberry_states.iloc[0])

################################## Order data for time step prediction ###################################################################
robot_pos_trajectory_input = []
robot_vel_trajectory_input = []
strawberry_state_input = []
strawberry_state_label = []
for i in range(0, (robot_velocitys.shape[0] - trajectory_length)):
  robot_pos_trajectory_input.append(robot_positions.iloc[i:i+trajectory_length + 1].values.flatten())
  robot_vel_trajectory_input.append(robot_velocitys.iloc[i:i+trajectory_length + 1].values.flatten())  # includes the start state of the robot.
  strawberry_state_input.append(strawberry_states.iloc[i].values.flatten())
  strawberry_state_label.append(strawberry_states.iloc[i+trajectory_length].values.flatten())  # does not include the start state of the strawberry. i+1:
robot_pos_trajectory_input = np.stack(robot_pos_trajectory_input, axis=0)
robot_vel_trajectory_input = np.stack(robot_vel_trajectory_input, axis=0)
strawberry_state_input = np.stack(strawberry_state_input, axis=0)
strawberry_state_label = np.stack(strawberry_state_label, axis=0)

print(robot_pos_trajectory_input.shape)
print(len(robot_pos_trajectory_input))
print(len(robot_pos_trajectory_input[0]))
print(robot_pos_trajectory_input[0])
# for i in range(0, (robot_velocitys.shape[0] - trajectory_length)):
#   robot_pos_trajectory_input.append(np.concatenate(robot_positions.iloc[i:i+trajectory_length + 1].to_numpy()))  # includes the start state of the robot.
#   robot_vel_trajectory_input.append(np.concatenate(robot_velocitys.iloc[i:i+trajectory_length + 1].to_numpy()))  # includes the start state of the robot.
#   strawberry_state_input.append(strawberry_states.iloc[i].to_numpy())
#   strawberry_state_label.append(np.concatenate(strawberry_states.iloc[i+1:i+trajectory_length + 1].to_numpy()))  # does not include the start state of the strawberry.
# print(type(robot_pos_trajectory_input))
# print(len(robot_pos_trajectory_input))

################################## split data test and train ###################################################################
robot_pos_trajectory_input_train = tf.convert_to_tensor(robot_pos_trajectory_input[0:25000])
robot_pos_trajectory_input_test = tf.convert_to_tensor(robot_pos_trajectory_input[25000:len(robot_pos_trajectory_input)])
robot_vel_trajectory_input_train = tf.convert_to_tensor(robot_vel_trajectory_input[0:25000])
robot_vel_trajectory_input_test = tf.convert_to_tensor(robot_vel_trajectory_input[25000:len(robot_vel_trajectory_input)])
strawberry_state_input_train = tf.convert_to_tensor(strawberry_state_input[0:25000])
strawberry_state_input_test = tf.convert_to_tensor(strawberry_state_input[25000:len(strawberry_state_input)])
strawberry_state_label_train = tf.convert_to_tensor(strawberry_state_label[0:25000])
strawberry_state_label_test = tf.convert_to_tensor(strawberry_state_label[25000:len(strawberry_state_label)])
print(strawberry_state_input_train.shape)

strawberry_input_layer = keras.layers.Input(shape=(21,))
dense_3_3 = keras.layers.Dense(45, activation=tf.keras.layers.LeakyReLU(alpha=0.1))(strawberry_input_layer)
dense_4_3 = keras.layers.Dense(55, activation=tf.keras.layers.LeakyReLU(alpha=0.1))(dense_3_3)

robot_pose_input_layer = keras.layers.Input(shape=((7*(trajectory_length+1)),))
dense_3_1 = keras.layers.Dense(45, activation=tf.keras.layers.LeakyReLU(alpha=0.1))(robot_pose_input_layer)
dense_4_1 = keras.layers.Dense(55, activation=tf.keras.layers.LeakyReLU(alpha=0.1))(dense_3_1)

robot_vel_input_layer = keras.layers.Input(shape=((7*(trajectory_length+1)),))
dense_3_2 = keras.layers.Dense(45, activation=tf.keras.layers.LeakyReLU(alpha=0.1))(robot_vel_input_layer)
dense_4_2 = keras.layers.Dense(55, activation=tf.keras.layers.LeakyReLU(alpha=0.1))(dense_3_2)

concat = keras.layers.concatenate([dense_4_1, dense_4_2, dense_4_3])

dense_5 = keras.layers.Dense(160, activation=tf.keras.layers.LeakyReLU(alpha=0.1))(concat)
dense_6 = keras.layers.Dense(120, activation=tf.keras.layers.LeakyReLU(alpha=0.1))(dense_5)
output_layer = keras.layers.Dense((21), activation="linear")(dense_6)

custom_model = keras.models.Model(inputs=[strawberry_input_layer, robot_pose_input_layer, robot_vel_input_layer] , outputs=output_layer)

# Compile the model
custom_model.compile(optimizer='adam',loss='mean_absolute_error', metrics=['mse','accuracy'])
monitor = EarlyStopping(monitor='val_loss', min_delta=1e-3, patience=2, verbose=1, mode='auto', restore_best_weights=True)

history = custom_model.fit([strawberry_state_input_train, robot_pos_trajectory_input_train, robot_vel_trajectory_input_train], strawberry_state_label_train, callbacks=[monitor], batch_size=32, validation_split=0.0, epochs=15)

score = custom_model.evaluate([strawberry_state_input_test, robot_pos_trajectory_input_test, robot_vel_trajectory_input_test], strawberry_state_label_test) 

# predict_customNet_dense = custom_model.predict([strawberry_state_input_test, robot_pos_trajectory_input_test, robot_vel_trajectory_input_test])

# err_matrix_customNet_dense = strawberry_state_label_test - predict_customNet_dense
# customNet_err_mean = np.mean(abs(err_matrix_customNet_dense))
# print("AlexNet mean error values for each output: ")
# print(customNet_err_mean)
# a = np.where(err_matrix_customNet_dense > 0.01)
# a = np.asarray(list(zip(*a)))
# print("number of err elements higher than 0.01: {}".format(a.shape))

# predict_customNet_dense.shape

# custom_model.summary()
# custom_model.save('/content/drive/My Drive/Masters Year/data_mfpc/custom_model_no_image.h5')

# print(predict_customNet_dense[0])
# print(strawberry_state_label_test.iloc[0])

predict_customNet_dense = custom_model.predict([strawberry_state_input_test, robot_pos_trajectory_input_test, robot_vel_trajectory_input_test])

err_matrix_customNet_dense = strawberry_state_label_test - predict_customNet_dense
customNet_err_mean = np.mean(abs(err_matrix_customNet_dense))
print("AlexNet mean error values for each output: ")
print(customNet_err_mean)
a = np.where(err_matrix_customNet_dense > 0.01)
a = np.asarray(list(zip(*a)))
print("number of err elements higher than 0.01: {}".format(a.shape))

predict_customNet_dense.shape

custom_model.summary()
custom_model.save('/content/drive/My Drive/Masters Year/data_mfpc/custom_model_no_image.h5')

print(predict_customNet_dense[0])
print(strawberry_state_label_test[0])