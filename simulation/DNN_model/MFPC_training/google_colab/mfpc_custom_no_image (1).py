# -*- coding: utf-8 -*-
"""MFPC_custom_no_image.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eICQ69-fUUmT-QOYclFfAGouAJHDTw-b
"""

# Unzip data
!unzip "/content/drive/My Drive/Masters Year/data_mfpc/data_set_005.zip"

import cv2
import random
import matplotlib
import numpy as np
import pandas as pd
from PIL import Image
import tensorflow as tf
from tensorflow import keras
import matplotlib.image as mpimg
from matplotlib import pyplot as plt
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Activation, Dropout, Flatten, Conv2D, MaxPooling2D
from tensorflow.keras.callbacks import EarlyStopping
np.random.seed(1000)
from sklearn import preprocessing
from tensorflow.keras.models import Model
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.preprocessing import image
from tensorflow.keras.applications.resnet import preprocess_input

################################## Hyper Parameters ##################################################################
data_set_length = 11000  # 11054
trajectory_length = 3  # Not including start state

################################# Robot vel and pos ###################################################################
robot_positions = pd.read_csv('/content/data_set_005/robot_pos/data_set_' + str(0) + '_robot_data_store_position.csv', header=None)
robot_velocitys = pd.read_csv('/content/data_set_005/robot_vel/data_set_' + str(0) + '_robot_data_store_velocity.csv', header=None)
for i in range(1, data_set_length):
    print(i)
    robot_positions = pd.concat([robot_positions, pd.read_csv('/content/data_set_005/robot_pos/data_set_' + str(i) + '_robot_data_store_position.csv', header=None)])
    robot_velocitys = pd.concat([robot_velocitys, pd.read_csv('/content/data_set_005/robot_vel/data_set_' + str(i) + '_robot_data_store_velocity.csv', header=None)])

################################## Standardization for Robot States ###################################################################
robot_positions_names = robot_positions.columns
scaler = preprocessing.StandardScaler()
myScaler = scaler.fit(robot_positions)
robot_positions = myScaler.transform(robot_positions)
robot_positions = pd.DataFrame(robot_positions, columns=robot_positions_names)
print(robot_positions.shape)

robot_velocitys_names = robot_velocitys.columns
scaler = preprocessing.StandardScaler()
myScaler = scaler.fit(robot_velocitys)
robot_velocitys = myScaler.transform(robot_velocitys)
robot_velocitys = pd.DataFrame(robot_velocitys, columns=robot_velocitys_names)
print(robot_velocitys.shape)

################################## Load Strawberry Data ##################################################################
strawberry_1 = pd.read_csv('/content/data_set_005/straw_1/data_set_' + str(0) + '_strawberry_data_store_1.csv', delimiter=',', error_bad_lines=False,  header=None).drop([3,4,5,6], axis=1)
strawberry_2 = pd.read_csv('/content/data_set_005/straw_2/data_set_' + str(0) + '_strawberry_data_store_2.csv', delimiter=',', error_bad_lines=False, header=None).drop([3,4,5,6], axis=1)
strawberry_3 = pd.read_csv('/content/data_set_005/straw_3/data_set_' + str(0) + '_strawberry_data_store_3.csv', delimiter=',', error_bad_lines=False, header=None).drop([3,4,5,6], axis=1)
strawberry_4 = pd.read_csv('/content/data_set_005/straw_4/data_set_' + str(0) + '_strawberry_data_store_4.csv', delimiter=',', error_bad_lines=False, header=None).drop([3,4,5,6], axis=1)
strawberry_5 = pd.read_csv('/content/data_set_005/straw_5/data_set_' + str(0) + '_strawberry_data_store_5.csv', delimiter=',', error_bad_lines=False, header=None).drop([3,4,5,6], axis=1)
strawberry_states = strawberry_1
blank = strawberry_2
counter = 0
for i in range(counter, 2):
    strawberry_states = pd.concat([strawberry_states, blank], axis=1)

for i in range(1, data_set_length):
    print("here 1 >> ", i)
    strawberry_cluster_state = pd.read_csv('/content/data_set_005/straw_1/data_set_' + str(i) + '_strawberry_data_store_1.csv', delimiter=',', error_bad_lines=False, header=None).drop([3,4,5,6], axis=1)
    strawberry_2 = pd.read_csv('/content/data_set_005/straw_2/data_set_' + str(i) + '_strawberry_data_store_2.csv', delimiter=',', error_bad_lines=False, header=None).drop([3,4,5,6], axis=1)
    strawberry_3 = pd.read_csv('/content/data_set_005/straw_3/data_set_' + str(i) + '_strawberry_data_store_3.csv', delimiter=',', error_bad_lines=False, header=None).drop([3,4,5,6], axis=1)
    strawberry_4 = pd.read_csv('/content/data_set_005/straw_4/data_set_' + str(i) + '_strawberry_data_store_4.csv', delimiter=',', error_bad_lines=False, header=None).drop([3,4,5,6], axis=1)
    strawberry_5 = pd.read_csv('/content/data_set_005/straw_5/data_set_' + str(i) + '_strawberry_data_store_5.csv', delimiter=',', error_bad_lines=False, header=None).drop([3,4,5,6], axis=1)
    counter = 0
    if strawberry_2[0][0] != 100 and counter < 2:
        strawberry_cluster_state = pd.concat([strawberry_cluster_state, strawberry_2], axis=1)
        counter += 1
    if strawberry_3[0][0] != 100 and counter < 2:
        strawberry_cluster_state = pd.concat([strawberry_cluster_state, strawberry_3], axis=1)
        counter += 1
    if strawberry_4[0][0] != 100 and counter < 2:
        strawberry_cluster_state = pd.concat([strawberry_cluster_state, strawberry_4], axis=1)
        counter += 1
    if strawberry_5[0][0] != 100 and counter < 2:
        strawberry_cluster_state = pd.concat([strawberry_cluster_state, strawberry_5], axis=1)
        counter += 1
    for i in range(counter, 2):
        strawberry_cluster_state = pd.concat([strawberry_cluster_state, blank], axis=1)
    strawberry_states = pd.concat([strawberry_states, strawberry_cluster_state], axis=0)
print(strawberry_states.iloc[0])

################################## Standardization for Strawberry States ###################################################################
# strawberry_state_names = strawberry_states.columns
# scaler = preprocessing.StandardScaler()
# myScaler = scaler.fit(strawberry_states)
# strawberry_states = myScaler.transform(strawberry_states)
# strawberry_states = pd.DataFrame(strawberry_states, columns=strawberry_state_names)
# print(strawberry_states.shape)
# print(strawberry_states.iloc[0])

################################## Order data for time step prediction ###################################################################
robot_pos_trajectory_input = []
robot_vel_trajectory_input = []
strawberry_state_input = []
strawberry_state_label = []
for i in range(0, (robot_velocitys.shape[0] - trajectory_length)):
  print("here 2 >> ", i)
  robot_pos_trajectory_input.append(robot_positions.iloc[i:i+trajectory_length + 1].values.flatten())
  robot_vel_trajectory_input.append(robot_velocitys.iloc[i:i+trajectory_length + 1].values.flatten())  # includes the start state of the robot.
  strawberry_state_input.append(strawberry_states.iloc[i].values.flatten())
  strawberry_state_label.append(strawberry_states.iloc[i+trajectory_length].values.flatten())  # does not include the start state of the strawberry. i+1:
robot_pos_trajectory_input = np.stack(robot_pos_trajectory_input, axis=0)
robot_vel_trajectory_input = np.stack(robot_vel_trajectory_input, axis=0)
strawberry_state_input = np.stack(strawberry_state_input, axis=0)
strawberry_state_label = np.stack(strawberry_state_label, axis=0)

print(robot_pos_trajectory_input.shape)
print(len(robot_pos_trajectory_input))
print(len(robot_pos_trajectory_input[0]))
print(robot_pos_trajectory_input[0])


################################## Cut data that has no change (in robot state) ###################################################################
robot_pos_trajectory_input__ = []
robot_vel_trajectory_input__ = []
strawberry_state_input__ = []
strawberry_state_label__ = []
for i in range(0, len(robot_pos_trajectory_input)):
  print("here 3 >> ", i)
  dif = [0,0,0,0,0,0,0]
  for j in range(0, (trajectory_length*7), 7):
    dif = robot_pos_trajectory_input[i][j:j+7] - robot_pos_trajectory_input[i][j+7:j+14] + dif
  if sum(abs(dif)) > 0.2:
    robot_pos_trajectory_input__.append(robot_pos_trajectory_input[i])
    robot_vel_trajectory_input__.append(robot_vel_trajectory_input[i])
    strawberry_state_input__.append(strawberry_state_input[i])
    strawberry_state_label__.append(strawberry_state_label[i])

robot_pos_trajectory_input = robot_pos_trajectory_input__
robot_vel_trajectory_input = robot_vel_trajectory_input__
strawberry_state_input = strawberry_state_input__
strawberry_state_label = strawberry_state_label__
print(len(robot_pos_trajectory_input))
print(len(robot_vel_trajectory_input))
print(len(strawberry_state_input))
print(len(strawberry_state_label))


# ################################## Scale the data up so training can achive better accuracy ###################################################################
# robot_pos_trajectory_input[i] = int(robot_pos_trajectory_input[i] * 100000)
# robot_vel_trajectory_input[i] = int(robot_vel_trajectory_input[i] * 100000)
# strawberry_state_input[i] = int(strawberry_state_input[i] * 100000)
# strawberry_state_label[i] = int(strawberry_state_label[i] * 100000)

# ################################# Shuffle The data set ###################################################################
# random_shuffle_order = random.sample(range(len(robot_pos_trajectory_input[0])), len(robot_pos_trajectory_input[0]))

# robot_pos_trajectory_input_shuffled = []
# robot_vel_trajectory_input_shuffled = []
# strawberry_state_input_shuffled = []
# strawberry_state_label_shuffled = []

# for value in random_shuffle_order:
#   robot_pos_trajectory_input_shuffled.append(robot_pos_trajectory_input[value]) 
#   robot_vel_trajectory_input_shuffled.append(robot_vel_trajectory_input[value]) 
#   strawberry_state_input_shuffled.append(strawberry_state_input[value]) 
#   strawberry_state_label_shuffled.append(strawberry_state_label[value])

# ################################## split data test and train ###################################################################
# robot_pos_trajectory_input_train = tf.convert_to_tensor(robot_pos_trajectory_input[0:int(len(robot_pos_trajectory_input)*0.75)])
# robot_pos_trajectory_input_test = tf.convert_to_tensor(robot_pos_trajectory_input[int(len(robot_pos_trajectory_input)*0.75):len(robot_pos_trajectory_input)])
# robot_vel_trajectory_input_train = tf.convert_to_tensor(robot_vel_trajectory_input[0:int(len(robot_pos_trajectory_input)*0.75)])
# robot_vel_trajectory_input_test = tf.convert_to_tensor(robot_vel_trajectory_input[int(len(robot_pos_trajectory_input)*0.75):len(robot_vel_trajectory_input)])
# strawberry_state_input_train = tf.convert_to_tensor(strawberry_state_input[0:int(len(robot_pos_trajectory_input)*0.75)])
# strawberry_state_input_test = tf.convert_to_tensor(strawberry_state_input[int(len(robot_pos_trajectory_input)*0.75):len(strawberry_state_input)])
# strawberry_state_label_train = tf.convert_to_tensor(strawberry_state_label[0:int(len(robot_pos_trajectory_input)*0.75)])
# strawberry_state_label_test = tf.convert_to_tensor(strawberry_state_label[int(len(robot_pos_trajectory_input)*0.75):len(strawberry_state_label)])
# print(strawberry_state_input_train.shape)

################################## Scale the data up so training can achive better accuracy ###################################################################
robot_pos_trajectory_input_scaled = []
robot_vel_trajectory_input_scaled = []
strawberry_state_input_scaled = []
strawberry_state_label_scaled = []
for i in range(0, len(robot_pos_trajectory_input)):
  robot_pos_trajectory_input_scaled.append([int(j * 100000) for j in robot_pos_trajectory_input[i]])
  robot_vel_trajectory_input_scaled.append([int(j * 100000) for j in robot_vel_trajectory_input[i]])
  strawberry_state_input_scaled.append([int(j * 100000) for j in strawberry_state_input[i]])
  strawberry_state_label_scaled.append([int(j * 100000) for j in strawberry_state_label[i]])

################################# Shuffle The data set ###################################################################
random_shuffle_order = random.sample(range(len(robot_pos_trajectory_input)), len(robot_pos_trajectory_input))

robot_pos_trajectory_input_shuffled = []
robot_vel_trajectory_input_shuffled = []
strawberry_state_input_shuffled = []
strawberry_state_label_shuffled = []

for value in random_shuffle_order:
  robot_pos_trajectory_input_shuffled.append(robot_pos_trajectory_input_scaled[value]) 
  robot_vel_trajectory_input_shuffled.append(robot_vel_trajectory_input_scaled[value]) 
  strawberry_state_input_shuffled.append(strawberry_state_input_scaled[value]) 
  strawberry_state_label_shuffled.append(strawberry_state_label_scaled[value])

print(robot_pos_trajectory_input_scaled[0])
print(robot_pos_trajectory_input_shuffled[0])
print(len(robot_pos_trajectory_input_shuffled))

################################## split data test and train ###################################################################
robot_pos_trajectory_input_train = tf.convert_to_tensor(robot_pos_trajectory_input_shuffled[0:int(len(robot_pos_trajectory_input_shuffled)*0.75)])
robot_pos_trajectory_input_test = tf.convert_to_tensor(robot_pos_trajectory_input_shuffled[int(len(robot_pos_trajectory_input_shuffled)*0.75):len(robot_pos_trajectory_input_shuffled)])
robot_vel_trajectory_input_train = tf.convert_to_tensor(robot_vel_trajectory_input_shuffled[0:int(len(robot_vel_trajectory_input_shuffled)*0.75)])
robot_vel_trajectory_input_test = tf.convert_to_tensor(robot_vel_trajectory_input_shuffled[int(len(robot_vel_trajectory_input_shuffled)*0.75):len(robot_vel_trajectory_input_shuffled)])
strawberry_state_input_train = tf.convert_to_tensor(strawberry_state_input_shuffled[0:int(len(robot_vel_trajectory_input_shuffled)*0.75)])
strawberry_state_input_test = tf.convert_to_tensor(strawberry_state_input_shuffled[int(len(robot_vel_trajectory_input_shuffled)*0.75):len(strawberry_state_input_shuffled)])
strawberry_state_label_train = tf.convert_to_tensor(strawberry_state_label_shuffled[0:int(len(robot_vel_trajectory_input_shuffled)*0.75)])
strawberry_state_label_test = tf.convert_to_tensor(strawberry_state_label_shuffled[int(len(robot_vel_trajectory_input_shuffled)*0.75):len(strawberry_state_label_shuffled)])
print(strawberry_state_input_train.shape)
print(strawberry_state_input_test.shape)

# ################################## Load Strawberry Data ##################################################################
# strawberry_1 = pd.read_csv('/content/data_set_005/straw_1/data_set_' + str(0) + '_strawberry_data_store_1.csv', delimiter=',', error_bad_lines=False,  header=None)
# strawberry_2 = pd.read_csv('/content/data_set_005/straw_2/data_set_' + str(0) + '_strawberry_data_store_2.csv', delimiter=',', error_bad_lines=False, header=None)
# strawberry_3 = pd.read_csv('/content/data_set_005/straw_3/data_set_' + str(0) + '_strawberry_data_store_3.csv', delimiter=',', error_bad_lines=False, header=None)
# strawberry_4 = pd.read_csv('/content/data_set_005/straw_4/data_set_' + str(0) + '_strawberry_data_store_4.csv', delimiter=',', error_bad_lines=False, header=None)
# strawberry_5 = pd.read_csv('/content/data_set_005/straw_5/data_set_' + str(0) + '_strawberry_data_store_5.csv', delimiter=',', error_bad_lines=False, header=None)
# strawberry_states = strawberry_1
# blank = strawberry_2
# counter = 0
# for i in range(counter, 2):
#     strawberry_states = pd.concat([strawberry_states, blank], axis=1)

# for i in range(1, data_set_length):
#     strawberry_cluster_state = pd.read_csv('/content/data_set_005/straw_1/data_set_' + str(i) + '_strawberry_data_store_1.csv', delimiter=',', error_bad_lines=False, header=None)
#     strawberry_2 = pd.read_csv('/content/data_set_005/straw_2/data_set_' + str(i) + '_strawberry_data_store_2.csv', delimiter=',', error_bad_lines=False, header=None)
#     strawberry_3 = pd.read_csv('/content/data_set_005/straw_3/data_set_' + str(i) + '_strawberry_data_store_3.csv', delimiter=',', error_bad_lines=False, header=None)
#     strawberry_4 = pd.read_csv('/content/data_set_005/straw_4/data_set_' + str(i) + '_strawberry_data_store_4.csv', delimiter=',', error_bad_lines=False, header=None)
#     strawberry_5 = pd.read_csv('/content/data_set_005/straw_5/data_set_' + str(i) + '_strawberry_data_store_5.csv', delimiter=',', error_bad_lines=False, header=None)
#     counter = 0
#     if strawberry_2[0][0] != 100 and counter < 2:
#         strawberry_cluster_state = pd.concat([strawberry_cluster_state, strawberry_2], axis=1)
#         counter += 1
#     if strawberry_3[0][0] != 100 and counter < 2:
#         strawberry_cluster_state = pd.concat([strawberry_cluster_state, strawberry_3], axis=1)
#         counter += 1
#     if strawberry_4[0][0] != 100 and counter < 2:
#         strawberry_cluster_state = pd.concat([strawberry_cluster_state, strawberry_4], axis=1)
#         counter += 1
#     if strawberry_5[0][0] != 100 and counter < 2:
#         strawberry_cluster_state = pd.concat([strawberry_cluster_state, strawberry_5], axis=1)
#         counter += 1
#     for i in range(counter, 2):
#         strawberry_cluster_state = pd.concat([strawberry_cluster_state, blank], axis=1)
#     strawberry_states = pd.concat([strawberry_states, strawberry_cluster_state], axis=0)
# print(strawberry_states.iloc[0])

# ################################## Standardization for Strawberry States ###################################################################
# strawberry_state_names = strawberry_states.columns
# scaler = preprocessing.StandardScaler()
# myScaler = scaler.fit(strawberry_states)
# strawberry_states = myScaler.transform(strawberry_states)
# strawberry_states = pd.DataFrame(strawberry_states, columns=strawberry_state_names)
# print(strawberry_states.shape)
# print(strawberry_states.iloc[0])

# ################################## Order data for time step prediction ###################################################################
# robot_pos_trajectory_input = []
# robot_vel_trajectory_input = []
# strawberry_state_input = []
# strawberry_state_label = []
# for i in range(0, (robot_velocitys.shape[0] - trajectory_length)):
#   robot_pos_trajectory_input.append(robot_positions.iloc[i:i+trajectory_length + 1].values.flatten())
#   robot_vel_trajectory_input.append(robot_velocitys.iloc[i:i+trajectory_length + 1].values.flatten())  # includes the start state of the robot.
#   strawberry_state_input.append(strawberry_states.iloc[i].values.flatten())
#   strawberry_state_label.append(strawberry_states.iloc[i+trajectory_length].values.flatten())  # does not include the start state of the strawberry. i+1:
# robot_pos_trajectory_input = np.stack(robot_pos_trajectory_input, axis=0)
# robot_vel_trajectory_input = np.stack(robot_vel_trajectory_input, axis=0)
# strawberry_state_input = np.stack(strawberry_state_input, axis=0)
# strawberry_state_label = np.stack(strawberry_state_label, axis=0)

# print(robot_pos_trajectory_input.shape)
# print(len(robot_pos_trajectory_input))
# print(len(robot_pos_trajectory_input[0]))
# print(robot_pos_trajectory_input[0])
# # for i in range(0, (robot_velocitys.shape[0] - trajectory_length)):
# #   robot_pos_trajectory_input.append(np.concatenate(robot_positions.iloc[i:i+trajectory_length + 1].to_numpy()))  # includes the start state of the robot.
# #   robot_vel_trajectory_input.append(np.concatenate(robot_velocitys.iloc[i:i+trajectory_length + 1].to_numpy()))  # includes the start state of the robot.
# #   strawberry_state_input.append(strawberry_states.iloc[i].to_numpy())
# #   strawberry_state_label.append(np.concatenate(strawberry_states.iloc[i+1:i+trajectory_length + 1].to_numpy()))  # does not include the start state of the strawberry.
# # print(type(robot_pos_trajectory_input))
# # print(len(robot_pos_trajectory_input))

# ################################## Cut data that has no change (in robot state) ###################################################################
# robot_pos_trajectory_input__ = []
# robot_vel_trajectory_input__ = []
# strawberry_state_input__ = []
# strawberry_state_label__ = []
# for i in range(0, len(robot_pos_trajectory_input)):
#   dif = [0,0,0,0,0,0,0]
#   for j in range(0, (trajectory_length*7), 7):
#     dif = robot_pos_trajectory_input[i][j:j+7] - robot_pos_trajectory_input[i][j+7:j+14] + dif
#   if sum(abs(dif)) > 0.2:
#     robot_pos_trajectory_input__.append(robot_pos_trajectory_input[i])
#     robot_vel_trajectory_input__.append(robot_vel_trajectory_input[i])
#     strawberry_state_input__.append(strawberry_state_input[i])
#     strawberry_state_label__.append(strawberry_state_label[i])

# robot_pos_trajectory_input = robot_pos_trajectory_input__
# robot_vel_trajectory_input = robot_vel_trajectory_input__
# strawberry_state_input = strawberry_state_input__
# strawberry_state_label = strawberry_state_label__
# print(len(robot_pos_trajectory_input))
# print(len(robot_vel_trajectory_input))
# print(len(strawberry_state_input))
# print(len(strawberry_state_label))

# ################################## split data test and train ###################################################################
# robot_pos_trajectory_input_train = tf.convert_to_tensor(robot_pos_trajectory_input[0:int(len(robot_pos_trajectory_input)*0.75)])
# robot_pos_trajectory_input_test = tf.convert_to_tensor(robot_pos_trajectory_input[int(len(robot_pos_trajectory_input)*0.75):len(robot_pos_trajectory_input)])
# robot_vel_trajectory_input_train = tf.convert_to_tensor(robot_vel_trajectory_input[0:int(len(robot_pos_trajectory_input)*0.75)])
# robot_vel_trajectory_input_test = tf.convert_to_tensor(robot_vel_trajectory_input[int(len(robot_pos_trajectory_input)*0.75):len(robot_vel_trajectory_input)])
# strawberry_state_input_train = tf.convert_to_tensor(strawberry_state_input[0:int(len(robot_pos_trajectory_input)*0.75)])
# strawberry_state_input_test = tf.convert_to_tensor(strawberry_state_input[int(len(robot_pos_trajectory_input)*0.75):len(strawberry_state_input)])
# strawberry_state_label_train = tf.convert_to_tensor(strawberry_state_label[0:int(len(robot_pos_trajectory_input)*0.75)])
# strawberry_state_label_test = tf.convert_to_tensor(strawberry_state_label[int(len(robot_pos_trajectory_input)*0.75):len(strawberry_state_label)])
# print(strawberry_state_input_train.shape)

strawberry_input_layer = keras.layers.Input(shape=(9,))
dense_3_3 = keras.layers.Dense(64, activation="relu")(strawberry_input_layer)
dense_4_3 = keras.layers.Dense(32, activation="relu")(dense_3_3)

robot_pose_input_layer = keras.layers.Input(shape=((7*(trajectory_length+1)),))
dense_3_1 = keras.layers.Dense(64, activation="relu")(robot_pose_input_layer)
dense_4_1 = keras.layers.Dense(32, activation="relu")(dense_3_1)

robot_vel_input_layer = keras.layers.Input(shape=((7*(trajectory_length+1)),))
dense_3_2 = keras.layers.Dense(64, activation="relu")(robot_vel_input_layer)
dense_4_2 = keras.layers.Dense(32, activation="relu")(dense_3_2)

concat = keras.layers.concatenate([dense_3_3, dense_3_1, dense_3_2])

dense_5 = keras.layers.Dense(64, activation="relu")(concat)
dense_6 = keras.layers.Dense(128, activation="relu")(dense_5)
dense_7 = keras.layers.Dense(64, activation="relu")(dense_6)
dense_8 = keras.layers.Dense(32, activation="relu")(dense_7)

output_layer = keras.layers.Dense((9), activation="linear")(dense_8)

custom_model = keras.models.Model(inputs=[strawberry_input_layer, robot_pose_input_layer, robot_vel_input_layer] , outputs=output_layer)

# strawberry_input_layer = keras.layers.Input(shape=(9,))
# dense_3_3 = keras.layers.Dense(64, activation="relu")(strawberry_input_layer)
# dense_4_3 = keras.layers.Dense(32, activation="relu")(dense_3_3)
# dense_5_3 = keras.layers.Dense(64, activation="relu")(dense_4_3)
# dense_6_3 = keras.layers.Dense(32, activation="relu")(dense_5_3)

# robot_pose_input_layer = keras.layers.Input(shape=((7*(trajectory_length+1)),))
# dense_3_1 = keras.layers.Dense(64, activation="relu")(robot_pose_input_layer)
# dense_4_1 = keras.layers.Dense(32, activation="relu")(dense_3_1)
# dense_5_1 = keras.layers.Dense(64, activation="relu")(dense_4_1)
# dense_6_1 = keras.layers.Dense(32, activation="relu")(dense_5_1)

# robot_vel_input_layer = keras.layers.Input(shape=((7*(trajectory_length+1)),))
# dense_3_2 = keras.layers.Dense(64, activation="relu")(robot_vel_input_layer)
# dense_4_2 = keras.layers.Dense(32, activation="relu")(dense_3_2)
# dense_5_2 = keras.layers.Dense(64, activation="relu")(dense_4_2)
# dense_6_2 = keras.layers.Dense(32, activation="relu")(dense_5_2)

# concat = keras.layers.concatenate([dense_3_3, dense_3_1, dense_3_2])

# dense_5 = keras.layers.Dense(64, activation="relu")(concat)
# dense_6 = keras.layers.Dense(128, activation="relu")(dense_5)
# dense_7 = keras.layers.Dense(64, activation="relu")(dense_6)
# dense_8 = keras.layers.Dense(128, activation="relu")(dense_7)
# dense_9 = keras.layers.Dense(64, activation="relu")(dense_8)

# output_layer = keras.layers.Dense((9), activation="linear")(dense_9)

# custom_model = keras.models.Model(inputs=[strawberry_input_layer, robot_pose_input_layer, robot_vel_input_layer] , outputs=output_layer)
# strawberry_input_layer = keras.layers.Input(shape=(9,))
# dense_3_3 = keras.layers.Dense(32, activation="relu")(strawberry_input_layer)
# dense_4_3 = keras.layers.Dense(32, activation="relu")(dense_3_3)

# robot_pose_input_layer = keras.layers.Input(shape=((7*(trajectory_length+1)),))
# dense_3_1 = keras.layers.Dense(32, activation="relu")(robot_pose_input_layer)
# dense_4_1 = keras.layers.Dense(32, activation="relu")(dense_3_1)

# robot_vel_input_layer = keras.layers.Input(shape=((7*(trajectory_length+1)),))
# dense_3_2 = keras.layers.Dense(32, activation="relu")(robot_vel_input_layer)
# dense_4_2 = keras.layers.Dense(32, activation="relu")(dense_3_2)

# concat = keras.layers.concatenate([dense_3_3, dense_3_1, dense_3_2])

# dense_5 = keras.layers.Dense(64, activation=tf.keras.layers.LeakyReLU(alpha=0.1))(concat)
# dense_6 = keras.layers.Dense(128, activation=tf.keras.layers.LeakyReLU(alpha=0.1))(dense_5)
# dense_7 = keras.layers.Dense(64, activation=tf.keras.layers.LeakyReLU(alpha=0.1))(dense_6)
# dense_8 = keras.layers.Dense(128, activation=tf.keras.layers.LeakyReLU(alpha=0.1))(dense_7)
# dense_9 = keras.layers.Dense(64, activation=tf.keras.layers.LeakyReLU(alpha=0.1))(dense_8)

# output_layer = keras.layers.Dense((9), activation="linear")(dense_9)

# custom_model = keras.models.Model(inputs=[strawberry_input_layer, robot_pose_input_layer, robot_vel_input_layer] , outputs=output_layer)

# Compile the model
custom_model.compile(optimizer='adam',loss='mean_absolute_error', metrics=['mae'])
monitor = EarlyStopping(monitor='val_loss', min_delta=1e-3, patience=2, verbose=1, mode='auto', restore_best_weights=True)

history = custom_model.fit([strawberry_state_input_train, robot_pos_trajectory_input_train, robot_vel_trajectory_input_train], strawberry_state_label_train, callbacks=[monitor], batch_size=32, validation_split=0.2, epochs=50)

score = custom_model.evaluate([strawberry_state_input_test, robot_pos_trajectory_input_test, robot_vel_trajectory_input_test], strawberry_state_label_test) 

# predict_customNet_dense = custom_model.predict([strawberry_state_input_test, robot_pos_trajectory_input_test, robot_vel_trajectory_input_test])

# err_matrix_customNet_dense = strawberry_state_label_test - predict_customNet_dense
# customNet_err_mean = np.mean(abs(err_matrix_customNet_dense))
# print("AlexNet mean error values for each output: ")
# print(customNet_err_mean)
# a = np.where(err_matrix_customNet_dense > 0.01)
# a = np.asarray(list(zip(*a)))
# print("number of err elements higher than 0.01: {}".format(a.shape))

# predict_customNet_dense.shape

# custom_model.summary()
# custom_model.save('/content/drive/My Drive/Masters Year/data_mfpc/custom_model_no_image.h5')

# print(predict_customNet_dense[0])
# print(strawberry_state_label_test.iloc[0])

predict_customNet_dense = custom_model.predict([strawberry_state_input_test, robot_pos_trajectory_input_test, robot_vel_trajectory_input_test])

err_matrix_customNet_dense = strawberry_state_label_test - predict_customNet_dense
customNet_err_mean = np.mean(abs(err_matrix_customNet_dense))
print("AlexNet mean error values for each output: ")
print(customNet_err_mean)
# a = np.where(err_matrix_customNet_dense > 0.01 * 1000)
# a = np.asarray(list(zip(*a)))
# print("number of err elements higher than 0.01: {}".format(a.shape))

# predict_customNet_dense.shape

custom_model.summary()
custom_model.save('/content/drive/My Drive/Masters Year/data_mfpc/custom_model_no_image_014.h5')

print([i / 100000 for i in predict_customNet_dense[10000]])
print([float(i / 100000) for i in strawberry_state_label_test[10000]])
print("------------------------------------------------------------------------------")
print([i / 100000 for i in predict_customNet_dense[10001]])
print([float(i / 100000) for i in strawberry_state_label_test[10001]])